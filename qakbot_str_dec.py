import idaapi
import idautils
import binascii 
import ida_bytes
#-------------------------#
# athor : zw01f 
# this code decrypt strings in qakbot samples automatically using the address of enc strings and key then add comments in ida with the result 
# note : some strings need to be resolved dynamically , see python log .
#----------- used functions ------------- #
def read_data_ida(address,size):
	data = idc.get_bytes(address, size)
	return data
def xor_decryption(data,key):
	dec_data = ''
	for i in range(len(data)):
	    dec_data += chr(data[i] ^ key[i % 0x5a])
	return dec_data
def search_by_index(ind):
	return(dec_data[ind:].split('\x00')[0])
def set_comment(address, text):
    idc.set_cmt(address, text,0)
    # set_hexrays_comment(address, text)
def hex_to_int(x):
	if type(x) == int :
		return x 
	return (int(x[:-1], 16))
#---------------- -----------------#
def do_magic(dec_data,references):
	for ref in references:
		prev_ins = idc.prev_head(ref) #get address of previous line . 
		mnem = idc.print_insn_mnem(prev_ins) # get mnemonic
		if mnem == 'push' :
			if idc.get_operand_type(prev_ins,0) == 5 :
				ind = print_operand(prev_ins,0) 
				# print(search_by_index(decimal_int))
				set_comment(ref,search_by_index(hex_to_int(ind)))
			else : 
				set_comment(ref,"can't be resolved statically")
				print('not resolved ', hex(ref))
				# print('using push but not immediate' , hex(ref)) #debuging 
		elif mnem in  ['mov' , 'xor'] :
			# get second operand -ok--> this is the arg 
			# not work --> go prev line -> do that again .
			if idc.get_operand_type(prev_ins,1) == 5 : #immediate value == 5 
				ind = print_operand(prev_ins,1) #get second operand 
				set_comment(ref,search_by_index(hex_to_int(ind)))
			else :
				prev_2_ins = idc.prev_head(prev_ins) #get address of previous line . 
				mnem_2 = idc.print_insn_mnem(prev_2_ins) # get mnemonic
				if mnem_2 == 'push' :
					if idc.get_operand_type(prev_2_ins,0) == 5 :
						ind = print_operand(prev_2_ins,0)
						set_comment(ref,search_by_index(hex_to_int(ind)))
					else : 
						set_comment(ref,"can't be resolved statically")
						print('not resolved ', hex(ref))

						# print('using push but not immediate value ' , hex(ref)) #debuging work here
				elif mnem_2 == 'mov':
					if idc.get_operand_type(prev_2_ins,1) == 5 : #immediate value == 5 
						ind = print_operand(prev_2_ins,1) #get second operand 
						set_comment(ref,search_by_index(hex_to_int(ind)))
					else :
						set_comment(ref,"can't be resolved statically")
						print('not resolved ', hex(ref))
		else :
				print('error in the algorithm' , hex(ref)) #debuging work here
#-------------------MAIN---------------#
#---------- read enc strings and key -------- # 
dec_data_1 = xor_decryption(read_data_ida(0x1001D5A8,3660),read_data_ida(0x1001E3F8,104))
dec_data_2 = xor_decryption(read_data_ida(0x1001D0B0,1267),read_data_ida(0x1001D050,104))
#-----------Get reference of function---------------#
reference_1 = list(idautils.CodeRefsTo(idc.get_name_ea_simple("mw_w_dec_fun_3660_1"), 0)) #codeRefs to need "ea" as arguemt . 
reference_1 = reference_1 + list(idautils.CodeRefsTo(idc.get_name_ea_simple('mw_w_dec_fun_3660') , 0))

reference_2 = list(idautils.CodeRefsTo(idc.get_name_ea_simple('mw_w_dec_fun_1267_1'), 0))
reference_2 = reference_2 + list(idautils.CodeRefsTo(idc.get_name_ea_simple('mw_w_dec_fun_1267'), 0))
#----------Do magic --------------#
do_magic(dec_data_1,reference_1)
do_magic(dec_data_2,reference_2)

